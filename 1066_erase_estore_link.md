---
post_number: "1066"
title: "Erasing Extensible Storage with Linked Files"
slug: "erase_estore_link"
author: "Jeremy Tammik"
tags: ['csharp', 'elements', 'family', 'filtering', 'parameters', 'revit-api', 'sheets', 'transactions', 'views']
source_file: "1066_erase_estore_link.htm"
original_url: "https://thebuildingcoder.typepad.com/blog/1066_erase_estore_link.html"
---

### Erasing Extensible Storage with Linked Files

Here is a query and resolution raised by Marc in the discussion forum on
[erasing extensible storage data with linked files](http://forums.autodesk.com/t5/Revit-API/InternalException-when-using-Schema-EraseSchemaAndAllEntities/td-p/4598127),
followed by a reminder of the need to regenerate the model to
[avoid accessing stale data](#3) and
hint of possible things to come related to
[Revit and cloud computing](#4):

#### Erasing Extensible Storage Data with Linked Files

**Question:** I am calling the method Schema.EraseSchemaAndAllEntities in a project containing linked documents, and it is throwing an InternalException.
How can this be avoided, please?

I see a report of a similar issue in the article on
[deleting and updating extensible storage schema](http://thebuildingcoder.typepad.com/blog/2013/08/deleting-and-updating-extensible-storage-schema.html).

Can you confirm that this issue is caused by the linked files?

**Answer:** Basically, the Revit SDK ExtensibleStorageUtility shows you how to use this method.
I believe it should work perfectly well even if entities using the schema still exist.

By the way, here is a list of most of The Building Coder
[extensible storage related topics](http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.23).

It strikes me as rather strange that in your sample code, you only have a transaction open on the main document.

The Schema.EraseSchemaAndAllEntities method will delete storage of this schema in ***all*** open documents.

I wonder how this will affect the other linked documents if you have no transaction open for them.

I would suggest running this with only one document open in the current Revit session.

**Response:** I can confirm that the InternalException was caused by having projects linked in the document.

I have to unload all linked files first, run the method Schema.EraseSchemaAndAllEntities method, and then load the files again.

This is the final custom method that worked for me including the transaction:

```csharp
  public void DeleteSchema()
  {
    using( Transaction trans = new Transaction( \_doc ) )
    {
      trans.Start( "Delete Schema" );
      Schema schema = Schema.Lookup( \_schemaGuid );
      Schema.EraseSchemaAndAllEntities( schema, false );
      trans.Commit();
    }
  }
```

Many thanks to Marc for exploring and solving this issue!

#### Regenerate to Avoid Accessing Stale Data

We have looked at numerous issues in the past where developers ran into problems – or, rather, created them for themselves – by modifying something in the model and then attempted to read the stale data without regenerating it first.

Here is another example that shows clearly how easy it can be to miss this fact if you do not make a habit of checking for this possibility as one of the first things to do when running into mysterious problems:

**Question:** I'm trying to find the connectors of a view using:
```csharp
  collector = new FilteredElementCollector( famDoc );
  collector.OfClass( typeof( ConnectorElement ) );

  ICollection<ElementId> connectors
    = collector.ToElementIds();

  if( connectors.Count > 0 )
    view.HideElements( connectors );
```

This works fine if I do that on a existing 3D view, but if I create the view myself by calling CreateIsometric like this it does not:

```csharp
  view = View3D.CreateIsometric( famDoc,
    viewFamilyType.Id );
```

Then the connectors remain visible in the view exported PNG. This also happens for any other kind of element I try to hide; it works well on an existing 3D view but not in a newly created one.

I attached a sample project that generates two pictures: one is a modification of an existing view and has the connectors hidden; the other one uses a newly generated view where the connectors cannot be hidden.
If I do this inside the DocumentOpened event, none of the methods hide the connectors.

How can I hide elements in a newly created view generated by View3D.CreateIsometric, please?

**Answer:** I am happy to report that this problem is easy to fix and the Revit API is working properly, completely as expected.

You are creating a situation in which you are working with stale data.

If you make any modifications whatsoever to the model, you need to regenerate it again before reading.

Here are some previous examples of this kind of situation and when and how to regenerate the BIM, going all the way back to the year 2010:

- [Manual Regeneration Option Danger](http://thebuildingcoder.typepad.com/blog/2010/04/manual-regeneration-mode-danger.html)
- [Regeneration Option Best Practices](http://thebuildingcoder.typepad.com/blog/2010/04/regeneration-option-best-practices.html)
- [To Regenerate or Not to Regenerate...](http://thebuildingcoder.typepad.com/blog/2010/06/to-regenerate-or-not-to-regenerate.html)
- [Refresh Referencing Sheet Parameter Display](http://thebuildingcoder.typepad.com/blog/2010/11/refresh-referencing-sheet-parameter-display.html)
- [Setting Text Width Requires Regen](http://thebuildingcoder.typepad.com/blog/2010/11/setting-text-width-requires-regen.html)
- [Extra Transaction or Regeneration Required](http://thebuildingcoder.typepad.com/blog/2012/12/extra-transaction-or-regeneration-required.html)
- [Regenerate between plane and dimension creation](http://adndevblog.typepad.com/aec/2013/01/it-is-easy-to-miss-this-regenerating-the-model.html)

The topic of regeneration is also related to the
[temporary transaction trick](http://thebuildingcoder.typepad.com/blog/2012/10/the-temporary-transaction-trick-for-gross-slab-data.html),
the associated suggestion to
[encapsulate multiple transactions in a transaction group](http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html),
commit the individual transactions and then roll bock the entire group instead.

Every time a transaction is committed, a regeneration is automatically included.

In your case, hiding the connectors and creating a new view is obviously modifying the model before it is read by the image export.

Once a to regenerate before exporting is added, the process works just the way you presumably want:

```csharp
  // Hide connectors

  FilteredElementCollector collector
    = new FilteredElementCollector(view.Document);

  collector.OfClass(typeof(ConnectorElement));

  ICollection<ElementId> connectors
    = collector.ToElementIds();

  if (connectors.Count > 0)
    view.HideElements(connectors);

  view.Document.Regenerate(); // <---- Add this! ------

  // Export view
```

#### Revit and Cloud Computing

Here is a quick pointer to an interesting interview with Architosh on
[running Revit through a Web Browser](http://architosh.com/2013/11/autodesk-talks-to-architosh-about-revit-through-web-browser) on
any device, and several other big Autodesk CAD applications as well.